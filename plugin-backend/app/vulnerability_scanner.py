import requests
from bs4 import BeautifulSoup
import re
import ssl
import socket
from urllib.parse import urlparse
from googleapiclient.discovery import build
from OpenSSL import crypto
import jsbeautifier

def get_html(url):
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.text
    except requests.RequestException as e:
        print(f"Error al obtener {url}: {e}")
        return None


def check_xss_vulnerability(html):
    details = []
    print("Verificando vulnerabilidades XSS...")
    xss_patterns = [
        re.compile(r'<script>.*?</script>', re.IGNORECASE),
        re.compile(r'\"<.*?\".*?>', re.IGNORECASE)
    ]
    for pattern in xss_patterns:
        if pattern.search(html):
            print("Vulnerabilidad XSS encontrada")
            details.append({
                "Descripción": "Se encontraron etiquetas de script o patrones de entrada sospechosos.",
                "Patrón": pattern.pattern,
                "HTML": BeautifulSoup(html, 'html.parser').prettify()
            })
    if details:
        return True, details
    print("No se encontraron vulnerabilidades XSS")
    return False, ["No se encontraron vulnerabilidades XSS"]



def check_csrf_vulnerability(html):
    details = []
    print("Verificando vulnerabilidades CSRF...")
    soup = BeautifulSoup(html, 'html.parser')
    forms = soup.find_all('form')
    for form in forms:
        if not form.find('input', {'name': 'csrf_token'}):
            form_details = {
                "Acción": form.get('action'),
                "Método": form.get('method'),
                "HTML": BeautifulSoup(str(form), 'html.parser').prettify()
            }
            print("Vulnerabilidad CSRF encontrada")
            details.append(form_details)
    if details:
        return True, details
    print("No se encontraron vulnerabilidades CSRF")
    return False, ["No se encontraron vulnerabilidades CSRF"]



def check_sql_injection_vulnerability(url):
    details = []
    print("Verificando vulnerabilidades de inyección SQL...")
    sqli_test_url = url + "' OR '1'='1"
    try:
        response = requests.get(sqli_test_url)
        if response.status_code == 200 and "syntax error" in response.text.lower():
            print("Vulnerabilidad de inyección SQL encontrada")
            details.append("Punto potencial de inyección SQL encontrado.")
            return True, details
    except requests.RequestException as e:
        print(f"Error al verificar inyección SQL para {url}: {e}")
    print("No se encontraron vulnerabilidades de inyección SQL")
    return False, ["No se encontraron vulnerabilidades de inyección SQL"]


def check_https(url):
    details = []
    print("Verificando si se utiliza HTTPS...")
    parsed_url = urlparse(url)
    is_https = parsed_url.scheme == 'https'
    if not is_https:
        details.append("La URL no utiliza HTTPS.")
    else:
        details.append("La URL utiliza HTTPS pero necesitamos verificar otras configuraciones de seguridad.")
        try:
            response = requests.get(url)
            hsts = response.headers.get('Strict-Transport-Security')
            if hsts:
                details.append("HSTS (HTTP Strict Transport Security) está habilitado.")
            else:
                details.append("HSTS (HTTP Strict Transport Security) no está habilitado.")
            if response.history and 'Location' in response.history[-1].headers:
                details.append("La redirección de HTTP a HTTPS está configurada correctamente.")
            else:
                details.append("La redirección de HTTP a HTTPS no está configurada correctamente.")
        except requests.RequestException as e:
            details.append(f"Error al verificar la configuración HTTPS: {e}")
    print(f"HTTPS utilizado: {is_https}")
    return is_https, details


def check_ssl_certificate(url):
    details = []
    print("Verificando certificado SSL...")
    try:
        parsed_url = urlparse(url)
        hostname = parsed_url.hostname

        cert_details = get_ssl_certificate_details(hostname)
        if cert_details:
            details.append("Certificado SSL válido encontrado.")
            details.extend(cert_details)
            return True, details
        else:
            details.append("No se encontró un certificado SSL válido.")
            return False, details
    except Exception as e:
        print(f"Error al verificar el certificado SSL para {url}: {e}")
        details.append(f"Error al verificar el certificado SSL: {e}")
        return False, details


def get_ssl_certificate_details(hostname):
    try:
        cert_details = []
        context = ssl.create_default_context()
        with socket.create_connection((hostname, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert(binary_form=True)
                x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, cert)
                cert_details.append(f"Subject: {x509.get_subject().CN}")
                cert_details.append(f"Issuer: {x509.get_issuer().CN}")
                cert_details.append(f"Version: {x509.get_version()}")
                cert_details.append(f"Serial Number: {x509.get_serial_number()}")
                cert_details.append(f"Not Before: {x509.get_notBefore().decode('utf-8')}")
                cert_details.append(f"Not After: {x509.get_notAfter().decode('utf-8')}")
                return cert_details
    except Exception as e:
        print(f"Error al obtener detalles del certificado SSL: {e}")
        return None


def check_security_headers(url):
    details = []
    print("Verificando cabeceras de seguridad...")
    try:
        response = requests.get(url)
        headers = response.headers
        security_headers = ['Content-Security-Policy', 'Strict-Transport-Security', 'X-Content-Type-Options', 'X-Frame-Options', 'X-XSS-Protection']
        missing_headers = [header for header in security_headers if header not in headers]
        if missing_headers:
            details.append(f"Faltan cabeceras de seguridad: {', '.join(missing_headers)}")
        print(f"Faltan cabeceras de seguridad: {missing_headers}")
        return bool(missing_headers), details
    except requests.RequestException as e:
        print(f"Error al obtener cabeceras para {url}: {e}")
        details.append(f"Error al obtener cabeceras: {e}")
        return False, details


def check_malicious_links(url):
    details = []
    api_key = 'AIzaSyAOeCFxrAxYbG--xoLA6ltYX_Mak_Ud5Vg'
    client = build('safebrowsing', 'v4', developerKey=api_key)
    body = {
        'client': {
            'clientId': 'victor',
            'clientVersion': '1.5.2'
        },
        'threatInfo': {
            'threatTypes': ['MALWARE', 'SOCIAL_ENGINEERING'],
            'platformTypes': ['ANY_PLATFORM'],
            'threatEntryTypes': ['URL'],
            'threatEntries': [{'url': url}]
        }
    }
    request = client.threatMatches().find(body=body)
    response = request.execute()

    if 'matches' in response:
        for match in response['matches']:
            details.append({
                "url": match['threat']['url'],
                "threatType": match['threatType'],
                "platformType": match['platformType']
            })
        return True, details

    return False, ["No se detectaron enlaces maliciosos"]


def check_malicious_scripts(html):
    details = []
    print("Verificando scripts maliciosos...")
    soup = BeautifulSoup(html, 'html.parser')
    scripts = soup.find_all('script')
    malicious_patterns = {
        re.compile(r'eval\(', re.IGNORECASE): "El uso de 'eval' permite la ejecución de código arbitrario, lo cual puede ser explotado para ejecutar comandos maliciosos.",
        re.compile(r'unescape\(', re.IGNORECASE): "'unescape' puede ser utilizado para decodificar datos maliciosos que luego pueden ser ejecutados.",
        re.compile(r'document\.write\(', re.IGNORECASE): "'document.write' puede inyectar contenido malicioso directamente en la página, lo que puede llevar a ataques de XSS."
    }
    for script in scripts:
        script_content = script.string
        if script_content:
            beautified_script = jsbeautifier.beautify(script_content)
            for pattern, danger in malicious_patterns.items():
                if pattern.search(beautified_script):
                    script_details = {
                        "Contenido": beautified_script,
                        "Patrón": pattern.pattern,
                        "Peligro": danger
                    }
                    print("Script malicioso encontrado")
                    details.append(script_details)
    if details:
        return True, details
    print("No se encontraron scripts maliciosos")
    return False, ["No se encontraron scripts maliciosos"]



def check_suspicious_redirects(url):
    details = []
    print("Verificando redirecciones sospechosas...")
    try:
        response = requests.get(url, allow_redirects=True)
        redirect_history = response.history

        if len(redirect_history) > 3:  # Umbral para redirecciones sospechosas
            for redirect in redirect_history:
                redirect_details = {
                    "url": redirect.url,
                    "status_code": redirect.status_code
                }
                details.append(f"Redirección detectada: {redirect_details}")
            details.append("Se encontraron múltiples redirecciones sospechosas.")
            return True, details
    except requests.RequestException as e:
        print(f"Error al verificar redirecciones para {url}: {e}")
        details.append(f"Error al verificar redirecciones: {e}")

    print("No se encontraron redirecciones sospechosas")
    return False, ["No se encontraron redirecciones sospechosas"]


def analyze_url(url):
    print(f"Analizando URL: {url}")
    html = get_html(url)
    if not html:
        print("Error al obtener la URL")
        return {'error': 'No se pudo obtener la URL'}

    vulnerabilities = {
        'https': check_https(url),
        'ssl': check_ssl_certificate(url),
        'xss': check_xss_vulnerability(html),
        'csrf': check_csrf_vulnerability(html),
        'sqli': check_sql_injection_vulnerability(url),
        'missing_security_headers': check_security_headers(url),
        'malicious_links': check_malicious_links(url),
        'malicious_scripts': check_malicious_scripts(html),
        'suspicious_redirects': check_suspicious_redirects(url)
    }

    # Asegúrate de que todas las claves tengan un estado booleano y una lista de detalles
    detailed_results = {
        k: {
            "estado": v[0] if isinstance(v[0], bool) else bool(v[0]),
            "detalles": v[1] if isinstance(v[1], list) else [v[1]]
        }
        for k, v in vulnerabilities.items()
    }

    print(f"Resultados del análisis: {detailed_results}")
    return detailed_results

